# 2.3 浮点数的表示和运算

## 2.3.1 浮点数的表示

### 1 浮点数的表示

浮点数通常表示为：
$$
N=r^E × M
$$

- r：阶码的底，通常为2
- E：**阶码**，反映浮点数的表示范围和小数点的实际位置，用**补码或移码**表示
- M：**尾数**，其位数反映了小数的精度，用**原码或补码**表示

> 例：阶码和尾数都用补码表示，求a、b的真值
>
> - a = 0,01; 1.1001
> - b = 0,01; 0.01001
>
> a：
>
> - 阶码0,01对应真值+1
> - 尾数0.1001对应真值-0.0111，也可看作-111右移四位： −7/2^4
> - 故 a=2^1×(−7/2^4)=−7/8
>
> b：
>
> - 阶码对应真值+1
> - 尾数0.01001对应真值+0.01001，也可看作+1001右移五位： +9/2^5
> - 故 b=2^1×9/2^5=9/16

### 2 浮点数的规格化

规定尾数的最高位必须是一个有效值。

**左规**：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数左移一位，阶码减1 ( 基数为2时)：

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/%E8%A7%84%E6%A0%BC%E5%8C%96.png)

**右规**：当浮点数运算的结果尾数出现溢出(双符号位为01或10)时，将尾数右移一位，阶码加1 (基数为2时)。

规格化后的尾数满足： 1/r≤|M|≤1

**规格化的目的**：增加数据表示的精度。

### 3 IEEE 754 标准

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/ieee754.png)

尾数前隐含一位1

|    类型    | 数阶 | 阶码 | 尾数数值 | 总位数 |    偏置值    |
| :--------: | :--: | :--: | :------: | :----: | :----------: |
|  短浮点数  |  1   |  8   |    23    |   32   |  7FH（127）  |
|  长浮点数  |  1   |  11  |    52    |   64   | 3FFH（1023） |
| 临时浮点数 |  1   |  15  |    64    |   80   |    3FFFH     |

- 规格化的短浮点数的真值为：
  $$
  (-1)^{S}\times 1.M \times 2^{E-127}
  $$
  
- 规格化的长浮点数的真值为：
  $$
  (-1)^{S}\times 1.M \times 2^{E-1023}
  $$

对于短浮点数而言，**偏置值取127**，此时阶码（移码）的表示范围为**-126~127**：

| 真值  |   补码    |   移码    |
| :---: | :-------: | :-------: |
| -128* | 1000 0000 | 1111 1111 |
| -127* | 1000 0001 | 0000 0000 |
| -126  | 1000 0010 | 0000 0001 |
|  ……   |    ……     |    ……     |
|   0   | 0000 0000 | 0111 1111 |
|  ……   |    ……     |    ……     |
|  127  | 0111 1111 | 1111 1110 |

-128和-127的作用：

- E=0且M = 0，则真值为0；

- E=0且
  $$
  M \neq 0
  $$
   为非规格化数，真值 =(−1)S×0.M×2−126 ；

- E=255且
  $$
  M \neq 0
  $$
  真值为‘NaN’（非数值）；

- E=255且M =0，真值为正或负无穷。

> 例：将 -0.75D 转换为IEEE 754 的单精度浮点数格式表示

> - 将十进制转化为二进制
>   - −0.75D=−0.11B
> - 将小数的高位变为1 （对应尾数隐含的1）
>   - −0.11=−(1.1)2×2^−1
> - 数符：1
> - 尾数：取小数点后面部分，并补0
>   - .1000 0000 0000 0000 0000 000
> - 阶码：真值+偏移量
>   - (−1+127)D=126D=01111110B
> - 结果：1 0111 1110 1000 0000 0000 0000 0000 000

> 例：IEEE 754的单精度浮点数 C0 A0 00 00 H的值是多少

> - 化为二进制
>
>   - 1100 0000 1010 0000 0000 0000 0000 0000
>   - 数符：1
>   - 阶码：1000 0001
>   - 尾数：0100 0000 0000 0000 0000 000
>
> - 尾数：加上隐含的1
>
>   - (1.01)2
>
> - 阶码
>
>   - 先看作无符号数：1000 0001B = 129D
>   - 移码-偏置值：129-127=2
>
> - 真值：
>   $$
>   -(1.01)*2\times 2^2=-(1.25)*{10}\times2^2=-5.0
>   $$

## 2.3.2 浮点数的运算

### 1 加减运算

**步骤：**对阶->尾数加减->规格化->舍入->判溢出

（1）**对阶：**使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1

（2）**尾数加减**

（3）**规格化**：左规或右规

（4）**舍入：****“0”舍“1”入法**：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1， 则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。

**恒置“1”法**：尾数右移时，不论丢掉的最高数值位是“1”还是“0”， 都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。

无舍入

（5）**判断溢出**

未发生溢出

### 2 强制类型转换

| 数据类型  | 16位机器 | 32位机器 | 64位机器 |
| :-------: | :------: | :------: | -------- |
|   char    |    8     |    8     | 8        |
|   short   |    16    |    16    | 16       |
|    int    |    16    |    32    | 32       |
|   long    |    32    |    32    | 64       |
| long long |    64    |    64    | 64       |
|   float   |    16    |    32    | 32       |
|  double   |    64    |    64    | 64       |

char --> int --> long --> double 以及 float --> double，不会损失精度。

对于32位系统：

- int：表示整数，范围为 −2^31∼2^31−1，有效数字32位
- float：表示整数及小数，范围 ±[2^−126∼2^127×(2−2^−23)] ，有效数字23+1=24位
- int --> float：可能损失精度（有效数字比float多）
- float --> int：可能**溢出**（超出int表示范围）及损失精度（小数部分）

